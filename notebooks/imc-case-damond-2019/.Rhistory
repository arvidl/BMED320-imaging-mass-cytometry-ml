install.packages(c("MASS", "mgcv", "nlme", "survival"))
install.packages("haven")
install.packages("dplyr")
install.packages("rmarkdown")
install.packages("ggplot2")
install.packages("tidyverse")
install.packages("perm")
install.packages("hrbrthemes")
install.packages("viridis")
install.packages("heatmaply")
install.packages("caret")
install.packages("psych")
install.packages("lme4")
install.packages("AppliedPredictiveModeling")
install.packages("Rcmdr")
install.packages(c("mnormt", "systemfonts"))
install.packages(c("mnormt", "systemfonts"))
install.packages("mnormt")
install.packages("systemfonts")
install.packages("systemfonts")
install.packages("systemfonts")
install.packages("permubiome")
library(permubiome)
help(permubiame)
??permubiame
install.packages("systemfonts")
install.packages("freetypeharfbuzz")
install.packages("systemfonts")
install.packages("systemfonts")
install.packages("Rcmdr")
install.packages("systemfonts")
install.packages(c("processx", "RcppArmadillo"))
install.packages(c("psych", "systemfonts"))
library("Rcmdr")
install.packages(c("callr", "cowplot", "insight", "jsonlite", "MASS", "quantreg", "stringi", "systemfonts", "xfun"))
install.packages("discretize")
install.packages("arules")
help(arules)
??arules
source('~/.active-rstudio-document')
source('~/Downloads/discretize.R')
source('~/Downloads/discretize.R')
discretizeDF(iris[sample(1:nrow(iris), 5),], methods = irisDisc)
install.packages(c("backports", "gplots", "htmlTable", "insight", "knitr", "lava", "matrixStats", "openssl", "openxlsx", "quantreg", "rpart.plot", "survival", "tinytex", "withr"))
install.packages(c("car", "rmarkdown", "systemfonts", "xfun"))
remotes::install_github("mlverse/torch")
install.packages("remotes")
remotes::install_github("mlverse/torch")
library(torch)
source('~/.active-rstudio-document')
y
identical(x, as_array(y))
x <- torch_tensor(1, requires_grad = TRUE)
w <- torch_tensor(2, requires_grad = TRUE)
b <- torch_tensor(3, requires_grad = TRUE)
y <- w * x + b
y$backward()
x$grad
#> torch_tensor
#>  2
#> [ CPUFloatType{1} ]
w$grad
#> torch_tensor
#>  1
#> [ CPUFloatType{1} ]
b$grad
#> torch_tensor
#>  1
#> [ CPUFloatType{1} ]
x <- torch_randn(100, 2)
y <- 0.1 + 0.5*x[,1] - 0.7*x[,2]
w <- torch_randn(2, 1, requires_grad = TRUE)
b <- torch_zeros(1, requires_grad = TRUE)
lr <- 0.5
for (i in 1:100) {
y_hat <- torch_mm(x, w) + b
loss <- torch_mean((y - y_hat$squeeze(1))^2)
loss$backward()
with_no_grad({
w$sub_(w$grad*lr)
b$sub_(b$grad*lr)
w$grad$zero_()
b$grad$zero_()
})
}
print(w)
#> torch_tensor
#> 1e-09 *
#>  5.2672
#>  -6.7969
#> [ CPUFloatType{2,1} ]
print(b)
#> torch_tensor
#> 0.01 *
#> -9.6802
#> [ CPUFloatType{1} ]
install.packages(c("broom", "cpp11", "htmlwidgets", "quantreg", "sandwich", "seriation"))
install.packages(c("effsize", "readr", "sandwich"))
install.packages("psych")
install.packages(c("clipr", "ps", "Rcmdr", "rlang", "sp"))
install.packages(c("callr", "cli", "cpp11", "e1071", "tibble"))
install.packages("pbdZMQ")
install.packages(c("broom", "data.table", "digest", "foreach", "Formula", "iterators", "labeling", "quantreg", "RcppArmadillo", "recipes", "statmod"))
install.packages(c("rmarkdown", "torch"))
install.packages(c("insight", "SQUAREM"))
install.packages(c("digest", "lme4", "nlme", "openxlsx"))
install.packages(c("backports", "codetools", "dbplyr", "generics", "lava", "testthat", "tinytex", "xfun"))
install.packages("dbplyr")
install.packages("dbplot")
install.packages("cpp11")
reticulate::repl_python()
reticulate::source_python('~/Untitled.py')
reticulate::repl_python()
reticulate::source_python('~/Untitled.py')
library(reticulate)
wd <- '/Users/arvid/GitHub/BMED320-imaging-mass-cytometry-ml/notebooks/imc-case-damond-2019'
setwd(wd)
print(getwd())
os <- import("os")
os$listdir()
library(reticulate)
# cat $HOME/.Renviron
# RETICULATE_PYTHON="/Users/arvid/opt/anaconda3/envs/imc/bin/python"
print(Sys.which("python"))
use_python("/Users/arvid/opt/anaconda3/envs/imc/bin/python", required=TRUE)
print(Sys.which("python"))
use_condaenv(condaenv ="imc", conda = "auto", required = TRUE)
library("reticulate")
py_discover_config()
reticulate::repl_python()
library(ggplot2)
ggplot(py$flights, aes(carrier, arr_delay)) + geom_point() + geom_jitter()
library(dplyr)
py$flights %>%
dplyr::select(carrier, dep_delay, arr_delay) %>%
tidyr::drop_na() %>%
group_by(carrier) %>%
summarize(mean_dep_delay = mean(dep_delay), mean_arr_delay = mean(arr_delay))
library(ggplot2)
py$flights %>%
tidyr::drop_na() %>%
group_by(carrier, month) %>%
summarize(mean_dep_delay = mean(dep_delay)) %>%
ggplot(aes(x=as.factor(month), y = mean_dep_delay, group = carrier, color=carrier))  +
geom_point() + geom_line() + xlab("Month") + ylab("Average Departure Delay")
setwd("~/GitHub/BMED320-imaging-mass-cytometry-ml/notebooks/imc-case-damond-2019")
library(reticulate)
wd <- '/Users/arvid/GitHub/BMED320-imaging-mass-cytometry-ml/notebooks/imc-case-damond-2019'
setwd(wd)
print(getwd())
os <- import("os")
os$listdir()
library(reticulate)
# cat $HOME/.Renviron
# RETICULATE_PYTHON="/Users/arvid/opt/anaconda3/envs/imc/bin/python"
print(Sys.which("python"))
use_python("/Users/arvid/opt/anaconda3/envs/imc/bin/python", required=TRUE)
print(Sys.which("python"))
use_condaenv(condaenv ="imc", conda = "auto", required = TRUE)
library("reticulate")
py_discover_config()
install.packages("oro.nifti")
install.packages("oro.dicom")
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
hist(img)
install.packages("fslr")
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
img@bitpix
img@datatype
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
print(max(img))
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
print(max(img))
print(dim(img))
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
print(max(img))
print(dim(img))
print(img@dim_)
hist(img)
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
print(max(img))
print(dim(img))
print(img@dim_)
print(pixdim(img))
hist(img)
library(oro.nifti)
img_imc = drop_img_dim(img)
dim(img_imc)
library("reticulate")
py_discover_config()
library(oro.nifti)
fn <- 'data/imc_37_chns.nii.gz'
img <- readNIfTI(fn)
class(img)
print(img)
slotNames(img)
print(img@bitpix)
print(img@datatype)
print(max(img))
print(dim(img))
print(img@dim_)
print(pixdim(img))
hist(img)
library(oro.nifti)
img_imc = squeeze(img)
library(oro.nifti)
library(magrittr)
img_imc = squeeze(img)
library(oro.nifti)
library(imager)
install.packages("imager")
library(oro.nifti)
library(imager)
img_imc = squeeze(img)
dim(img_imc)
library(imager)
img_imc = squeeze(img)
dim(img_imc)
install.packages("raster")
library(raster)
fnt <- 'data/E08_a0_full.tiff'
rst <- brick(fnt)
install.packages("rgdal")
library(raster)
library(rgdal)
fnt <- 'data/E08_a0_full.tiff'
rst <- brick(fnt)
plotRGB(rst, r=4, g=3, b=2, scale=10000, stretch="lin", main="RGB composite (b4,b3,b2) of E08_a0_full.tiff")
install.packages("RStoolbox")
library(cluster)
# Extract all values from the raster into a data frame
rstDF <- values(rst)
View(rstDF)
library(cluster)
# Initiate the raster datasets that will hold all clustering solutions
# from 2 groups/clusters up to 12
rstKM <- raster(rst[[1]])
rstCLARA <- raster(rst[[1]])
library(raster)
library(rgdal)
fnt <- 'data/E08_a0_full.tiff'
rst <- brick(fnt)
plotRGB(rst, r=4, g=3, b=2, scale=10000, stretch="lin", main="RGB composite (b4,b3,b2) of E08_a0_full.tiff")
library(cluster)
# Extract all values from the raster into a data frame
rstDF <- values(rst)
# Check NA's in the data
idx <- complete.cases(rstDF)
library(cluster)
# Initiate the raster datasets that will hold all clustering solutions
# from 2 groups/clusters up to 12
rstKM <- raster(rst[[1]])
rstCLARA <- raster(rst[[1]])
library(cluster)
for(nClust in 2:12){
cat("-> Clustering data for nClust =",nClust,"......")
# Perform K-means clustering
km <- kmeans(rstDF[idx,], centers = nClust, iter.max = 50)
# Perform CLARA's clustering (using manhattan distance)
cla <- clara(rstDF[idx, ], k = nClust, metric = "manhattan")
# Create a temporary integer vector for holding cluster numbers
kmClust <- vector(mode = "integer", length = ncell(rst))
claClust <- vector(mode = "integer", length = ncell(rst))
# Generate the temporary clustering vector for K-means (keeps track of NA's)
kmClust[!idx] <- NA
kmClust[idx] <- km$cluster
# Generate the temporary clustering vector for CLARA (keeps track of NA's too ;-)
claClust[!idx] <- NA
claClust[idx] <- cla$clustering
# Create a temporary raster for holding the new clustering solution
# K-means
tmpRstKM <- raster(rst[[1]])
# CLARA
tmpRstCLARA <- raster(rst[[1]])
# Set raster values with the cluster vector
# K-means
values(tmpRstKM) <- kmClust
# CLARA
values(tmpRstCLARA) <- claClust
# Stack the temporary rasters onto the final ones
if(nClust==2){
rstKM    <- tmpRstKM
rstCLARA <- tmpRstCLARA
}else{
rstKM    <- stack(rstKM, tmpRstKM)
rstCLARA <- stack(rstCLARA, tmpRstCLARA)
}
cat(" done!\n\n")
}
library(cluster)
# Write the clustering solutions for each algorithm
writeRaster(rstKM,"./data/E08_a0_full_KMeans_nc2_12.tiff", overwrite=TRUE)
writeRaster(rstCLARA,"./data/E08_a0_full_CLARA_nc2_12.tiff", overwrite=TRUE)
install.packages("clusterCrit")
library(clusterCrit)
# Start a data frame that will store all silhouette values
# for k-means and CLARA
clustPerfSI <- data.frame(nClust = 2:12, SI_KM = NA, SI_CLARA = NA)
for(i in 1:nlayers(rstKM)){ # Iterate through each layer
cat("-> Evaluating clustering performance for nClust =",(2:12)[i],"......")
# Extract random cell samples stratified by cluster
cellIdx_RstKM <- sampleStratified(rstKM[[i]], size = 2000)
cellIdx_rstCLARA <- sampleStratified(rstCLARA[[i]], size = 2000)
# Get cell values from the Stratified Random Sample from the raster
# data frame object (rstDF)
rstDFStRS_KM <- rstDF[cellIdx_RstKM[,1], ]
rstDFStRS_CLARA <- rstDF[cellIdx_rstCLARA[,1], ]
# Make sure all columns are numeric (intCriteria function is picky on this)
rstDFStRS_KM[] <- sapply(rstDFStRS_KM, as.numeric)
rstDFStRS_CLARA[] <- sapply(rstDFStRS_CLARA, as.numeric)
# Compute the sample-based Silhouette index for:
#
# K-means
clCritKM <- intCriteria(traj = rstDFStRS_KM,
part = as.integer(cellIdx_RstKM[,2]),
crit = "Silhouette")
# and CLARA
clCritCLARA <- intCriteria(traj = rstDFStRS_CLARA,
part = as.integer(cellIdx_rstCLARA[,2]),
crit = "Silhouette")
# Write the silhouette index value to clustPerfSI data frame holding
# all results
clustPerfSI[i, "SI_KM"]    <- clCritKM[[1]][1]
clustPerfSI[i, "SI_CLARA"] <- clCritCLARA[[1]][1]
cat(" done!\n\n")
}
library(clusterCrit)
# Start a data frame that will store all silhouette values
# for k-means and CLARA
clustPerfSI <- data.frame(nClust = 2:12, SI_KM = NA, SI_CLARA = NA)
for(i in 1:nlayers(rstKM)){ # Iterate through each layer
cat("-> Evaluating clustering performance for nClust =",(2:12)[i],"......")
# Extract random cell samples stratified by cluster
cellIdx_RstKM <- sampleStratified(rstKM[[i]], size = 2000)
cellIdx_rstCLARA <- sampleStratified(rstCLARA[[i]], size = 2000)
# Get cell values from the Stratified Random Sample from the raster
# data frame object (rstDF)
rstDFStRS_KM <- rstDF[cellIdx_RstKM[,1], ]
rstDFStRS_CLARA <- rstDF[cellIdx_rstCLARA[,1], ]
# Make sure all columns are numeric (intCriteria function is picky on this)
rstDFStRS_KM[] <- sapply(rstDFStRS_KM, as.numeric)
rstDFStRS_CLARA[] <- sapply(rstDFStRS_CLARA, as.numeric)
# Compute the sample-based Silhouette index for:
#
# K-means
clCritKM <- intCriteria(traj = rstDFStRS_KM,
part = as.integer(cellIdx_RstKM[,2]),
crit = "Silhouette")
# and CLARA
clCritCLARA <- intCriteria(traj = rstDFStRS_CLARA,
part = as.integer(cellIdx_rstCLARA[,2]),
crit = "Silhouette")
# Write the silhouette index value to clustPerfSI data frame holding
# all results
clustPerfSI[i, "SI_KM"]    <- clCritKM[[1]][1]
clustPerfSI[i, "SI_CLARA"] <- clCritCLARA[[1]][1]
cat(" done!\n\n")
}
